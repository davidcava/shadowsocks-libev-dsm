#!/bin/bash
# checked with: shellcheck -x

# Source package specific variable and functions
SVC_SETUP="$(dirname "$0")/service-setup"
if [ -r "${SVC_SETUP}" ]; then
    #shellcheck source=service-setup
    . "${SVC_SETUP}"
fi

SCRIPT_REDIRECT="$SCRIPT_DIR/redirect.sh"
SCRIPT_TPROXY="$SCRIPT_DIR/tproxy.sh"

start_daemon ()
{
    local sourcefiles
    if [ "$1" = "" ]; then
        sourcefiles="$CONFIG_DIR" # normal launch: start everything in the folder
    else
        sourcefiles="$1" # unit launch: only 1 file
    fi

    local CONF_FILE started retcode tcpredir udpredir
    started=0
    tcpredir=0
    udpredir=0

    #Look for any ss-<ssserver>-<name>.json config files in configuration etc folder, and optionaly ss-<ssserver>-<name>.params
    while read -r CONF_FILE
    do
        local SS_SERVER CONF_NAME PID_FILE CMD

        SS_SERVER=$(echo "$CONF_FILE" | sed -E 's,'"$CONFFILES_REGEX"',\2,')
        CONF_NAME=$(echo "$CONF_FILE" | sed -E 's,'"$CONFFILES_REGEX"',\4,')
        CONF_FULLNAME=$(echo "$CONF_FILE" | sed -E 's,'"$CONFFILES_REGEX"',\2\3,')

        PID_FILE="$PID_DIR/$SS_SERVER$CONF_FULLNAME.pid"

        CMD="synosystemctl start pkg-$SS_SERVER@$CONF_FULLNAME"

        if [ -f "$PID_FILE" ] && kill -0 "$(cat "$PID_FILE")" > /dev/null 2>&1; then
            echo "  $SS_SERVER $CONF_NAME is already running"
        else
            # tcp is inactive if option udp_only (default is active)
            local tcpmode
            if grep -E -q 'udp_only' "$CONF_FILE"; then
                tcpmode=0
            else
                tcpmode=1
            fi

            # udp is active if option tcp_and_udp or udp_only (default is inactive)
            local udpmode
            if grep -E -q 'tcp_and_udp|udp_only' "$CONF_FILE"; then
                udpmode=1
            else
                udpmode=0
            fi

            $CMD
            retcode=$?

            if [ "$retcode" != 0 ]
            then
                echo "Startup of $DNAME $SS_SERVER failed for config file $CONF_FILE" >> "$SYNOPKG_TEMP_LOGFILE"
            else
                started=1
            fi

            # Remember to run iptables redirection scripts if ss-redir is used
            if [ "$SS_SERVER" = "ss-redir" ] && [ "$tcpmode" = 1 ]; then
                tcpredir=1
            fi
            if [ "$SS_SERVER" = "ss-redir" ] && [ "$udpmode" = 1 ]; then
                udpredir=1
            fi
        fi
    done < <( find -L "$sourcefiles" -maxdepth 1 -regextype posix-extended -regex "$CONFFILES_REGEX" -type f )

    if [ "$started" = 1 ]
    then
        # At least 1 daemon could start, update the used ports toward DSM if needed
        "$SCRIPT_DIR/gensc.sh"
    else
        echo 'No shadowsocks service is currently started: create or check config file(s) ss-(local|server|redir|tunnel|manager)[-confname].json using the user interface or directly in folder: '"$CONFIG_DIR" >> "$SYNOPKG_TEMP_LOGFILE"
        exit 0 # Always return 0 because DSM does not show the config app if service is not considered started
    fi

    # Run network configuration scripts for ss-redir (iptables REDIRECT / TPROXY...)
    if [ "$tcpredir" = 1 ] && [ -f "$SCRIPT_REDIRECT" ]; then
        #if [[ -x "$SCRIPT_REDIRECT" && $(stat -c %A "$SCRIPT_REDIRECT") =~ r...-..-.$ ]]; then
        if [ -x "$SCRIPT_REDIRECT" ] && expr "$(stat -c %A "$SCRIPT_REDIRECT")" : .r...-..-.$ >>/dev/null; then
            "$SCRIPT_REDIRECT"
        else
            echo "ERROR: Script file must only be writable by its user: $SCRIPT_REDIRECT" >> "$SYNOPKG_TEMP_LOGFILE"
        fi
    fi
    if [ "$udpredir" = 1 ] && [ -f "$SCRIPT_TPROXY" ]; then
        if [ -x "$SCRIPT_TPROXY" ] && expr "$(stat -c %A "$SCRIPT_TPROXY")" : .r...-..-.$ >>/dev/null; then
            "$SCRIPT_TPROXY"
        else
            echo "ERROR: Script file must only be writable by its user: $SCRIPT_TPROXY" >> "$SYNOPKG_TEMP_LOGFILE"
        fi
    fi
}

stop_daemon ()
{
    local PID_FILE

    local sourcefiles
    if [ "$1" = "" ]; then
        sourcefiles="$PID_DIR" # normal launch: stop everything in the folder
    else
        sourcefiles="$PID_DIR/$1.pid" # unit stop: only 1 file
    fi

    while read -r PID_FILE
    do
        synosystemctl stop "$(synosystemctl get-unit-by-pid "$(cat "$PID_FILE")")"
    done < <( find -L "$sourcefiles" -maxdepth 1 -regextype posix-extended -regex '.*/'"$PIDFILES_REGEX" -type f )
}

daemon_status_unit ()
{
    local CONF_FILE SS_SERVER CONF_NAME PID_FILE

    CONF_FILE="$1"
    SS_SERVER=$(echo "$CONF_FILE" | sed -E 's,'"$CONFFILES_REGEX"',\2,')
    CONF_NAME=$(echo "$CONF_FILE" | sed -E 's,'"$CONFFILES_REGEX"',\4,')

    PID_FILE="$PID_DIR/$SS_SERVER${CONF_NAME:+-$CONF_NAME}.pid"

    if [ -f "$PID_FILE" ] && kill -0 "$(cat "$PID_FILE")" > /dev/null 2>&1; then
        [ -n "$2" ] || echo "  $SS_SERVER $CONF_NAME is running"
        return 0
    else
        [ -n "$2" ] || echo "  $SS_SERVER $CONF_NAME is not running"
        rm -f "$PID_FILE"
        return 1
    fi
}

# Status is True if at least 1 ss-<server> is running, False if none is running
# Quiet if called with first parameter = 0 
daemon_status ()
{
    local stopped CONF_FILE
    stopped=1

    while read -r CONF_FILE
    do
        if daemon_status_unit "$CONF_FILE" "$1"; then
            stopped=0
        fi
    done < <( find -L "${CONFIG_DIR}" -maxdepth 1 -regextype posix-extended -regex '.*/'"$CONFFILES_REGEX" -type f )

    return $stopped
}

wait_for_death ()
{
    local counter=$1
    local daemonpid=$2
    while [ "${counter}" -gt 0 ]; do
        kill -0 "$daemonpid" > /dev/null 2>&1 || return 0
    counter=$((counter-1))
        sleep 1
    done
    return 1
}

setvars_unit_file ()
{
    UNIT_SERVER=$(basename "$1" .json)
    UNIT_FILE="$CONFIG_DIR/$UNIT_SERVER.json"
}

exit_if_not_root ()
{
    if [ ! "$(id -u)" = "0" ]; then
	rootmsg="You need to grant root privileges to the package components. Connect though SSH, run the following command: sudo /var/packages/shadowsocks-libev/scripts/addprivileges. Then stop and start the package."
        echo "$rootmsg" >> "$SYNOPKG_TEMP_LOGFILE"
        echo "$rootmsg"
        exit 0 # We should exit 1 but this triggers a "repair", not what we want
    fi
}

# script is run from unexisting home directory of homeless user, which bugs some functions, so go to /tmp instead
# shellcheck disable=SC2164
cd "${TMPDIR-/tmp}"

exit_if_not_root

case $1 in
    start)
        if [ "$2" = "" ]; then
            echo "Starting $DNAME ..."
            start_daemon
            exit 0 # Always return 0 because DSM does not show the config app if service is not considered started
        else
            setvars_unit_file "$2"
            if [ ! -f "$UNIT_FILE" ]; then
                echo "$UNIT_FILE not found"
                exit 1
            elif daemon_status_unit "$UNIT_FILE" 0; then
                echo "$DNAME $UNIT_SERVER is already running"
            else
                echo "Starting $DNAME $UNIT_SERVER ..."
                start_daemon "$UNIT_FILE"
            fi
        fi
        ;;
    stop)
        if [ "$2" = "" ]; then
            if daemon_status 0; then
                echo "Stopping $DNAME ..."
                stop_daemon
            else
                echo "$DNAME is not running"
            fi
        else
            setvars_unit_file "$2"
            if daemon_status_unit "$UNIT_FILE" 0; then
                echo "Stopping $DNAME $UNIT_SERVER ..."
                stop_daemon "$UNIT_SERVER"
            else
                echo "$DNAME $UNIT_SERVER is not running"
            fi
        fi
        ;;
    status)
        if [ "$2" = "" ]; then
            if daemon_status; then
                exit 0
            else
                echo "$DNAME is not running"
                exit 0 # Always return 0 because DSM does not show the config app if service is not considered started
            fi
        else
            setvars_unit_file "$2"
            if daemon_status_unit "$UNIT_FILE"; then
                exit 0
            else
                exit 3
            fi
        fi
        ;;
    log)
        echo "${LOG_FILE}"
        ;;
    *)
        exit 1
        ;;
esac
